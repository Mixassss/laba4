#include <iostream>
#include <cmath>
#include <iomanip>

using namespace std;

// Функция для расчета значения исходного уравнения
double func(double x) {
    return (x * log(x + 1) - 1);
}

// Функция для расчета производной исходной функции
double derivative(double x) {
    return x / (x + 1) + log(x + 1);
}

// Метод Ньютона для решения уравнения
void newtonMethod(double x0, double epsilon) { //x0 - начальное предполагаемое значение корня и epsilon - желаемая точность результата.
    int N = 0;
    double xn = x0, xn1, diff; //В функции объявляются переменные: N для отслеживания количества итераций, xn для текущего приближения к корню, xn1 для нового значения приближения к корню, diff для вычисления разницы между xn1 и xn.
    
    cout << fixed << setprecision(6);
    cout << "| N  |    xn    |     xn+1 | xn+1 – xn|\n";
    
    do { //Запускается цикл do-while, который будет выполняться, пока разница между текущим и новым значением xn больше или равна epsilon.
        xn1 = xn - func(xn) / derivative(xn); //Внутри цикла значение xn1 пересчитывается по формуле метода Ньютона, используя функции func (функция, корень которой мы ищем) и derivative (производная функции).
        diff = abs(xn1 - xn); //После этого вычисляется разница diff между текущим и новым значением xn.
        cout << "| " << N << "  | " << xn << " | " << xn1 << " | " << diff << " |\n";
        xn = xn1; //Новое значение xn1 присваивается xn для продолжения итерации.
        N++;
    } while (diff >= epsilon);
    
    cout << "Корень уравнения методом Ньютона: " << xn << endl;
}

// Метод простых итераций для решения уравнения
void simpleIterationMethod(double x0, double epsilon) {
    int N = 0;
    double xn = x0, xn1, diff;
    // Вывод таблицы с результатами иллюстрирующей шаги метода простых итераций
    cout << fixed << setprecision(6);
    cout << "| N  |    xn    |     xn+1 | xn+1 – xn|\n";
    
    do {
         // Применение формулы для метода простых итераций
        xn1 = log(1/xn + 1); //Внутри цикла do-while происходит вычисление нового значения xn1 по формуле метода простых итераций: xn1 = log(1/xn + 1). Затем вычисляется разница diff между текущим и предыдущим значением xn.
        diff = abs(xn1 - xn);
        cout << "| " << N << "  | " << xn << " | " << xn1 << " | " << diff << " |\n";
        xn = xn1; //Значение переменной xn обновляется на xn1, и увеличивается счетчик N.
        N++;
    } while (diff >= epsilon); //Процесс повторяется, пока разница diff больше или равна epsilon.
    // Вывод найденного корня уравнения методом простых итераций
    cout << "Корень уравнения методом простых итераций: " << xn << endl;
}

//Метод половинного деления
void bisectionMethod(double a, double b, double epsilon) { //Функция bisectionMethod принимает три параметра: начальные значения a и b интервала, на котором ищется корень, и значение epsilon - точность, с которой мы хотим найти корень уравнения.
    if (func(a) * func(b) >= 0) { //Проверяется условие наличия корня на выбранном интервале. Если произведение значений функции на концах интервала больше или равно 0, то это означает, что корень на данном интервале отсутствует, и выводится сообщение об ошибке.
        cout << "Невозможно найти корень на указанном интервале. Пожалуйста, выберите другие a и b." << endl;
        return;
    }

    int N = 0;
    double an, bn;

    cout << setw(5) << "N" << setw(10) << "an" << setw(10) << "bn" << setw(15) << "bn - an" << endl;

    while ((b - a) >= epsilon) { //начинается цикл, в котором происходит деление отрезка пополам.
        double c = (a + b) / 2; //На каждой итерации вычисляется средняя точка c между a и b.

        if (func(c) == 0.0) { //Проверяется значение функции в точке c. Если оно равно 0, то корень найден и процесс завершается.
            break;
        } else if (func(c) * func(a) < 0) { //Иначе, если значение функции в точке c имеет разные знаки с функциями в точках a и c, то корень находится между a и c, поэтому b присваивается значение c.
            b = c;
        } else { //В противном случае корень находится между c и b, и a присваивается значение c.
            a = c;
        }
//Значения a и b обновляются на каждой итерации, сохраняются в переменных an и bn, и выводятся на экран с номером итерации N.
        an = a;
        bn = b;

        cout << setw(5) << N << setw(10) << an << setw(10) << bn << setw(15) << bn - an << endl;

        N++;
    }
    

    cout << "Корень уравнения на заданной точности равен: " << (a + b) / 2 << endl;
}

int main() {
    system ("chcp 65001");
    double a = 0.1; // начальное значение интервала [a, b]
    double b = 2.0; // начальное значение интервала [a, b]
    double x0 = 0.1; // начальное приближение
    double epsilon = 0.0001; // требуемая точность

    bisectionMethod (a, b, epsilon);
    
    newtonMethod (x0, epsilon); // Вызов функции для метода Ньютона
    simpleIterationMethod (x0, epsilon); // Вызов функции для метода простых итераций

    return 0;
}
